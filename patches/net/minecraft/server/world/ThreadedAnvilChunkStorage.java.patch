--- a/net/minecraft/server/world/ThreadedAnvilChunkStorage.java
+++ b/net/minecraft/server/world/ThreadedAnvilChunkStorage.java
@@ -317,7 +317,7 @@
          LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", this.saveDir.getName());
       } else {
          this.chunkHolders.values().stream().filter(ChunkHolder::isAccessible).forEach((chunkHolder) -> {
-            Chunk chunk = (Chunk)chunkHolder.getSavingFuture().getNow((Object)null);
+            Chunk chunk = (Chunk)chunkHolder.getSavingFuture().getNow(null);
             if (chunk instanceof ReadOnlyChunk || chunk instanceof WorldChunk) {
                this.save(chunk);
                chunkHolder.updateAccessibleStatus();
@@ -420,15 +420,15 @@
 
                Chunk chunk = (Chunk)optional.get();
                if (chunk.getStatus().isAtLeast(requiredStatus)) {
-                  CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> completableFuture;
+                  CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> completableFuture2;
                   if (requiredStatus == ChunkStatus.LIGHT) {
-                     completableFuture = this.upgradeChunk(holder, requiredStatus);
+                     completableFuture2 = this.upgradeChunk(holder, requiredStatus);
                   } else {
-                     completableFuture = requiredStatus.runLoadTask(this.world, this.structureManager, this.serverLightingProvider, (chunkx) -> this.convertToFullChunk(holder), chunk);
+                     completableFuture2 = requiredStatus.runLoadTask(this.world, this.structureManager, this.serverLightingProvider, (chunkx) -> this.convertToFullChunk(holder), chunk);
                   }
 
                   this.worldGenerationProgressListener.setChunkStatus(chunkPos, requiredStatus);
-                  return completableFuture;
+                  return completableFuture2;
                } else {
                   return this.upgradeChunk(holder, requiredStatus);
                }
@@ -482,11 +482,11 @@
       ChunkPos chunkPos = holder.getPos();
       CompletableFuture<Either<List<Chunk>, ChunkHolder.Unloaded>> completableFuture = this.getRegion(chunkPos, requiredStatus.getTaskMargin(), (i) -> this.getRequiredStatusForGeneration(requiredStatus, i));
       this.world.getProfiler().visit((Supplier<String>)(() -> "chunkGenerate " + requiredStatus.getId()));
-      return completableFuture.thenComposeAsync((either) -> (CompletableFuture)either.map((list) -> {
+      return completableFuture.thenComposeAsync((either) -> either.map((list) -> {
             try {
-               CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> completableFuture = requiredStatus.runGenerationTask(this.world, this.chunkGenerator, this.structureManager, this.serverLightingProvider, (chunk) -> this.convertToFullChunk(holder), list);
+               CompletableFuture<Either<Chunk, ChunkHolder.Unloaded>> completableFuture2 = requiredStatus.runGenerationTask(this.world, this.chunkGenerator, this.structureManager, this.serverLightingProvider, (chunk) -> this.convertToFullChunk(holder), list);
                this.worldGenerationProgressListener.setChunkStatus(chunkPos, requiredStatus);
-               return completableFuture;
+               return completableFuture2;
             } catch (Exception var8) {
                CrashReport crashReport = CrashReport.create(var8, "Exception generating new chunk");
                CrashReportSection crashReportSection = crashReport.addElement("Chunk to be generated");
@@ -536,7 +536,7 @@
                worldChunk.setLoadedToWorld(true);
                this.world.addBlockEntities(worldChunk.getBlockEntities().values());
                List<Entity> list = null;
-               TypeFilterableList[] var6 = worldChunk.getEntitySectionArray();
+               TypeFilterableList<Entity>[] var6 = worldChunk.getEntitySectionArray();
                int var7 = var6.length;
 
                for(int var8 = 0; var8 < var7; ++var8) {
@@ -659,9 +659,9 @@
             ChunkPos chunkPos = chunkHolder.getPos();
             Packet<?>[] packets = new Packet[2];
             this.getPlayersWatchingChunk(chunkPos, false).forEach((serverPlayerEntity) -> {
-               int j = getChebyshevDistance(chunkPos, serverPlayerEntity, true);
-               boolean bl = j <= j;
-               boolean bl2 = j <= this.watchDistance;
+               int jx = getChebyshevDistance(chunkPos, serverPlayerEntity, true);
+               boolean bl = jx <= j;
+               boolean bl2 = jx <= this.watchDistance;
                this.sendWatchPackets(serverPlayerEntity, chunkPos, packets, bl, bl2);
             });
          }
@@ -712,14 +712,14 @@
          ChunkHolder chunkHolder = (ChunkHolder)entry.getValue();
          Optional<Chunk> optional = Optional.ofNullable(chunkHolder.getCurrentChunk());
          Optional<WorldChunk> optional2 = optional.flatMap((chunk) -> chunk instanceof WorldChunk ? Optional.of((WorldChunk)chunk) : Optional.empty());
-         csvWriter.printRow(chunkPos.x, chunkPos.z, chunkHolder.getLevel(), optional.isPresent(), optional.map(Chunk::getStatus).orElse((Object)null), optional2.map(WorldChunk::getLevelType).orElse((Object)null), getFutureStatus(chunkHolder.getAccessibleFuture()), getFutureStatus(chunkHolder.getTickingFuture()), getFutureStatus(chunkHolder.getEntityTickingFuture()), this.ticketManager.getTicket(entry.getLongKey()), !this.isTooFarFromPlayersToSpawnMobs(chunkPos), optional2.map((worldChunk) -> Stream.of(worldChunk.getEntitySectionArray()).mapToInt(TypeFilterableList::size).sum()).orElse(0), optional2.map((worldChunk) -> worldChunk.getBlockEntities().size()).orElse(0));
+         csvWriter.printRow(chunkPos.x, chunkPos.z, chunkHolder.getLevel(), optional.isPresent(), optional.map(Chunk::getStatus).orElse(null), optional2.map(WorldChunk::getLevelType).orElse(null), getFutureStatus(chunkHolder.getAccessibleFuture()), getFutureStatus(chunkHolder.getTickingFuture()), getFutureStatus(chunkHolder.getEntityTickingFuture()), this.ticketManager.getTicket(entry.getLongKey()), !this.isTooFarFromPlayersToSpawnMobs(chunkPos), optional2.map((worldChunk) -> Stream.of(worldChunk.getEntitySectionArray()).mapToInt(TypeFilterableList::size).sum()).orElse(0), optional2.map((worldChunk) -> worldChunk.getBlockEntities().size()).orElse(0));
       }
 
    }
 
    private static String getFutureStatus(CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> completableFuture) {
       try {
-         Either<WorldChunk, ChunkHolder.Unloaded> either = (Either)completableFuture.getNow((Object)null);
+         Either<WorldChunk, ChunkHolder.Unloaded> either = (Either)completableFuture.getNow(null);
          return either != null ? (String)either.map((worldChunk) -> "done", (unloaded) -> "unloaded") : "not completed";
       } catch (CompletionException var2) {
          return "failed " + var2.getCause().getMessage();
@@ -779,10 +779,7 @@
    }
 
    public void updateCameraPosition(ServerPlayerEntity player) {
-      ObjectIterator i = this.entityTrackers.values().iterator();
-
-      while(i.hasNext()) {
-         ThreadedAnvilChunkStorage.EntityTracker entityTracker = (ThreadedAnvilChunkStorage.EntityTracker)i.next();
+      for (EntityTracker entityTracker : this.entityTrackers.values()) {
          if (entityTracker.entity == player) {
             entityTracker.updateCameraPosition(this.world.getPlayers());
          } else {
@@ -1140,3 +1137,5 @@
       }
    }
 }
+
+// Fukkit Marker
